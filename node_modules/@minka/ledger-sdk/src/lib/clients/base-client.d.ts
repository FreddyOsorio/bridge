import { LedgerRecord, JwtConfig, LedgerSignature, LedgerMeta } from '@minka/types';
import { Axios } from 'axios';
import { LedgerListParams } from '../types/list-params';
import { BaseListResponse, ListResponseClass } from '../types/list-response';
import { BaseRecordResponse, RecordResponseClass } from '../types/record-response';
export declare abstract class BaseClient {
    private apiClient;
    private authParams;
    protected readonly secure: Partial<JwtConfig>;
    constructor(apiClient: Axios, secure?: Partial<JwtConfig>);
    private buildRequestHash;
    private buildJwt;
    protected createRecord<T, R extends BaseRecordResponse<T, M>, M extends LedgerMeta = LedgerMeta>(path: string, ResponseClass: RecordResponseClass<T, R, M>, record: LedgerRecord<T, M>, authParams?: Partial<JwtConfig>): Promise<R>;
    protected updateRecord<T, R extends BaseRecordResponse<T, M>, M extends LedgerMeta = LedgerMeta>(path: string, ResponseClass: RecordResponseClass<T, R, M>, record: LedgerRecord<T, M>, authParams?: Partial<JwtConfig>): Promise<R>;
    protected signRecord<T, R extends BaseRecordResponse<T, M>, M extends LedgerMeta = LedgerMeta>(path: string, ResponseClass: RecordResponseClass<T, R, M>, signature: LedgerSignature, authParams?: Partial<JwtConfig>): Promise<R>;
    protected getRecord<T, R extends BaseRecordResponse<T, M>, M extends LedgerMeta = LedgerMeta>(path: string, ResponseClass: RecordResponseClass<T, R, M>, authParams?: Partial<JwtConfig>): Promise<R>;
    protected getRecordsList<T, R extends BaseListResponse<T, M>, M extends LedgerMeta = LedgerMeta>(path: string, ResponseClass: ListResponseClass<T, R, M>, params?: LedgerListParams): Promise<R>;
    setAuthParams(authParams: Partial<JwtConfig>): void;
}
